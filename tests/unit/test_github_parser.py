"""Tests for GitHub commit parsing and vendor attribution detection."""

from __future__ import annotations

import subprocess
import tempfile
from datetime import UTC, datetime, timedelta
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from ai_asst_mgr.operations.github_parser import (
    VENDOR_EMAIL_DOMAINS,
    VENDOR_SIGNATURES,
    Attribution,
    GitHubCommit,
    GitLogParser,
    create_attribution,
    detect_pr_attribution,
    detect_vendor_attribution,
    detect_vendor_attribution_detailed,
    find_git_repos,
    parse_git_log,
)


class TestGitHubCommit:
    """Tests for GitHubCommit dataclass."""

    def test_short_sha_returns_first_seven_chars(self) -> None:
        """Test that short_sha returns first 7 characters."""
        commit = GitHubCommit(
            sha="abc1234567890",
            repo="test/repo",
            branch="main",
            message="Test commit",
            author_name="Test Author",
            author_email="test@example.com",
            vendor_id=None,
            committed_at=datetime.now(tz=UTC),
        )
        assert commit.short_sha == "abc1234"

    def test_is_ai_attributed_true_when_vendor_set(self) -> None:
        """Test is_ai_attributed returns True when vendor_id is set."""
        commit = GitHubCommit(
            sha="abc1234567890",
            repo="test/repo",
            branch="main",
            message="Test commit",
            author_name="Test Author",
            author_email="test@example.com",
            vendor_id="claude",
            committed_at=datetime.now(tz=UTC),
        )
        assert commit.is_ai_attributed is True

    def test_is_ai_attributed_false_when_no_vendor(self) -> None:
        """Test is_ai_attributed returns False when vendor_id is None."""
        commit = GitHubCommit(
            sha="abc1234567890",
            repo="test/repo",
            branch="main",
            message="Test commit",
            author_name="Test Author",
            author_email="test@example.com",
            vendor_id=None,
            committed_at=datetime.now(tz=UTC),
        )
        assert commit.is_ai_attributed is False


class TestDetectVendorAttribution:
    """Tests for vendor attribution detection."""

    def test_detects_claude_code_signature(self) -> None:
        """Test detection of Claude Code signature."""
        message = "feat: add new feature\n\nGenerated with [Claude Code](https://claude.com)"
        assert detect_vendor_attribution(message) == "claude"

    def test_detects_claude_co_author(self) -> None:
        """Test detection of Claude co-author signature."""
        message = "fix: bug fix\n\nCo-Authored-By: Claude <noreply@anthropic.com>"
        assert detect_vendor_attribution(message) == "claude"

    def test_detects_anthropic_url(self) -> None:
        """Test detection of anthropic.com URL."""
        message = "docs: update\n\nSee https://anthropic.com/claude for details"
        assert detect_vendor_attribution(message) == "claude"

    def test_detects_gemini_signature(self) -> None:
        """Test detection of Gemini signature."""
        message = "feat: new feature\n\nGenerated by Gemini AI"
        assert detect_vendor_attribution(message) == "gemini"

    def test_detects_gemini_co_author(self) -> None:
        """Test detection of Gemini co-author."""
        message = "fix: bug\n\nCo-Authored-By: Gemini"
        assert detect_vendor_attribution(message) == "gemini"

    def test_detects_openai_signature(self) -> None:
        """Test detection of OpenAI signature."""
        message = "feat: add feature\n\nGenerated by OpenAI Codex"
        assert detect_vendor_attribution(message) == "openai"

    def test_detects_codex_signature(self) -> None:
        """Test detection of Codex signature."""
        message = "refactor: cleanup\n\nGenerated by Codex"
        assert detect_vendor_attribution(message) == "openai"

    def test_detects_openai_url(self) -> None:
        """Test detection of openai.com URL."""
        message = "docs: link\n\nhttps://openai.com/docs"
        assert detect_vendor_attribution(message) == "openai"

    def test_returns_none_for_human_commits(self) -> None:
        """Test that human commits return None."""
        message = "feat: manual implementation\n\nWritten by hand"
        assert detect_vendor_attribution(message) is None

    def test_case_insensitive_detection(self) -> None:
        """Test that detection is case-insensitive."""
        message = "GENERATED WITH [CLAUDE CODE]"
        assert detect_vendor_attribution(message) == "claude"

    def test_first_vendor_wins_on_multiple_matches(self) -> None:
        """Test that first matching vendor is returned."""
        # Claude signatures are checked first
        message = "Generated with [Claude Code] and Generated by OpenAI"
        assert detect_vendor_attribution(message) == "claude"


class TestVendorSignatures:
    """Tests for vendor signature patterns."""

    def test_claude_has_multiple_patterns(self) -> None:
        """Test Claude has multiple detection patterns."""
        assert len(VENDOR_SIGNATURES["claude"]) >= 3

    def test_gemini_has_multiple_patterns(self) -> None:
        """Test Gemini has multiple detection patterns."""
        assert len(VENDOR_SIGNATURES["gemini"]) >= 2

    def test_openai_has_multiple_patterns(self) -> None:
        """Test OpenAI has multiple detection patterns."""
        assert len(VENDOR_SIGNATURES["openai"]) >= 3


class TestGitLogParser:
    """Tests for GitLogParser class."""

    def test_build_git_log_command_basic(self) -> None:
        """Test building basic git log command."""
        parser = GitLogParser()
        cmd = parser._build_git_log_command(None, None, None, None)
        assert cmd[0] == "git"
        assert cmd[1] == "log"
        assert any("--format=" in c for c in cmd)

    def test_build_git_log_command_with_since(self) -> None:
        """Test git log command includes since date."""
        parser = GitLogParser()
        since = datetime(2024, 1, 1, tzinfo=UTC)
        cmd = parser._build_git_log_command(since, None, None, None)
        assert any("--since=" in c for c in cmd)

    def test_build_git_log_command_with_until(self) -> None:
        """Test git log command includes until date."""
        parser = GitLogParser()
        until = datetime(2024, 12, 31, tzinfo=UTC)
        cmd = parser._build_git_log_command(None, until, None, None)
        assert any("--until=" in c for c in cmd)

    def test_build_git_log_command_with_branch(self) -> None:
        """Test git log command includes branch."""
        parser = GitLogParser()
        cmd = parser._build_git_log_command(None, None, "feature-branch", None)
        assert "feature-branch" in cmd

    def test_build_git_log_command_with_limit(self) -> None:
        """Test git log command includes limit."""
        parser = GitLogParser()
        cmd = parser._build_git_log_command(None, None, None, 100)
        assert "-100" in cmd

    def test_build_git_log_command_respects_max_limit(self) -> None:
        """Test git log command respects MAX_COMMITS limit."""
        parser = GitLogParser()
        cmd = parser._build_git_log_command(None, None, None, 999999)
        # Should be capped at MAX_COMMITS
        assert f"-{parser.MAX_COMMITS}" in cmd

    def test_extract_branch_from_refs_head(self) -> None:
        """Test extracting branch from HEAD refs."""
        parser = GitLogParser()
        refs = "HEAD -> main, origin/main"
        assert parser._extract_branch_from_refs(refs) == "main"

    def test_extract_branch_from_refs_origin(self) -> None:
        """Test extracting branch from origin refs."""
        parser = GitLogParser()
        refs = "origin/feature-branch"
        assert parser._extract_branch_from_refs(refs) == "feature-branch"

    def test_extract_branch_from_empty_refs(self) -> None:
        """Test extracting branch from empty refs."""
        parser = GitLogParser()
        assert parser._extract_branch_from_refs("") is None
        assert parser._extract_branch_from_refs("tag: v1.0.0") is None

    def test_extract_branch_from_refs_with_head_no_arrow(self) -> None:
        """Test extracting branch from refs with HEAD but no arrow."""
        parser = GitLogParser()
        # Should fall through to look for origin/ pattern
        refs = "origin/develop, tag: v1.0.0"
        assert parser._extract_branch_from_refs(refs) == "develop"

    def test_extract_branch_from_refs_head_in_string_but_no_match(self) -> None:
        """Test refs containing 'HEAD -> ' but no matching ref starts with it."""
        parser = GitLogParser()
        # Contains "HEAD -> " but when split by ", ", no ref starts with "HEAD -> "
        # This tests the loop that doesn't find a match and falls through to origin/
        refs = "tag: v1.0.0, origin/feature, note: HEAD -> was here"
        assert parser._extract_branch_from_refs(refs) == "feature"

    def test_extract_branch_from_refs_no_match(self) -> None:
        """Test extracting branch from refs with no recognizable pattern."""
        parser = GitLogParser()
        # No HEAD -> or origin/ pattern
        refs = "tag: v1.0.0, grafted"
        assert parser._extract_branch_from_refs(refs) is None

    def test_parse_commit_block_valid(self) -> None:
        """Test parsing a valid commit block."""
        parser = GitLogParser()
        block = (
            "abc123|John Doe|john@example.com|2024-01-15T10:30:00+00:00|"
            "feat: add feature|HEAD -> main\n\nCommit body here"
        )
        commit = parser._parse_commit_block(block, "test/repo")
        assert commit is not None
        assert commit.sha == "abc123"
        assert commit.author_name == "John Doe"
        assert commit.author_email == "john@example.com"
        assert commit.branch == "main"

    def test_parse_commit_block_with_claude_signature(self) -> None:
        """Test parsing commit with Claude signature."""
        parser = GitLogParser()
        block = (
            "abc123|John|john@test.com|2024-01-15T10:30:00+00:00|feat: add feature|"
            "\n\nGenerated with [Claude Code]"
        )
        commit = parser._parse_commit_block(block, "test/repo")
        assert commit is not None
        assert commit.vendor_id == "claude"

    def test_parse_commit_block_invalid_format(self) -> None:
        """Test parsing invalid commit block returns None."""
        parser = GitLogParser()
        block = "invalid|data"  # Too few parts
        assert parser._parse_commit_block(block, "test/repo") is None

    def test_parse_commit_block_empty(self) -> None:
        """Test parsing empty commit block returns None."""
        parser = GitLogParser()
        assert parser._parse_commit_block("", "test/repo") is None

    def test_parse_commit_block_empty_lines_list(self) -> None:
        """Test parsing commit block with whitespace-only content."""
        parser = GitLogParser()
        # Test with various inputs that result in empty or invalid lines
        # Note: str.split('\n') never returns an empty list, but we test edge cases
        assert parser._parse_commit_block("\n\n\n", "test/repo") is None

    def test_parse_commit_block_with_naive_datetime(self) -> None:
        """Test parsing commit with naive datetime adds UTC timezone."""
        parser = GitLogParser()
        # Use a naive datetime format (no timezone info)
        block = "abc123|John|john@test.com|2024-01-15T10:30:00|feat: test|\n\nBody"
        commit = parser._parse_commit_block(block, "test/repo")
        assert commit is not None
        assert commit.committed_at.tzinfo == UTC

    def test_parse_git_log_output_skips_malformed_commits(self) -> None:
        """Test _parse_git_log_output skips malformed commits."""
        parser = GitLogParser()
        # Mix of valid and invalid commits
        output = """abc123|John|john@test.com|2024-01-15T10:30:00+00:00|feat: valid|
Body
---COMMIT_END---
invalid|only|three|parts
---COMMIT_END---
def456|Jane|jane@test.com|2024-01-16T11:00:00+00:00|fix: another valid|
Body2
---COMMIT_END---"""
        commits = parser._parse_git_log_output(output, "test/repo")
        # Should only get the 2 valid commits
        assert len(commits) == 2
        assert commits[0].sha == "abc123"
        assert commits[1].sha == "def456"

    def test_parse_git_log_output_handles_exception_in_parse(self) -> None:
        """Test _parse_git_log_output handles ValueError/IndexError exceptions."""
        parser = GitLogParser()

        # Create a commit block that will cause an exception during parsing
        # Use an invalid date format to trigger ValueError
        output = """abc123|John|john@test.com|invalid-date-format|feat: test|
Body
---COMMIT_END---
def456|Jane|jane@test.com|2024-01-16T11:00:00+00:00|fix: valid|
Body2
---COMMIT_END---"""
        commits = parser._parse_git_log_output(output, "test/repo")
        # Should only get the 1 valid commit, skip the one with invalid date
        assert len(commits) == 1
        assert commits[0].sha == "def456"

    @patch("subprocess.run")
    def test_is_git_repo_true(self, mock_run: MagicMock) -> None:
        """Test _is_git_repo returns True for valid repo."""
        mock_run.return_value = MagicMock(returncode=0)
        parser = GitLogParser()
        assert parser._is_git_repo(Path("/fake/repo")) is True

    @patch("subprocess.run")
    def test_is_git_repo_false_on_error(self, mock_run: MagicMock) -> None:
        """Test _is_git_repo returns False on subprocess error."""
        mock_run.side_effect = subprocess.SubprocessError()
        parser = GitLogParser()
        assert parser._is_git_repo(Path("/fake/not-repo")) is False

    @patch("subprocess.run")
    def test_get_repo_name_from_ssh_remote(self, mock_run: MagicMock) -> None:
        """Test getting repo name from SSH remote URL."""
        mock_run.return_value = MagicMock(stdout="git@github.com:user/my-repo.git\n", returncode=0)
        parser = GitLogParser()
        assert parser._get_repo_name(Path("/fake/repo")) == "user/my-repo"

    @patch("subprocess.run")
    def test_get_repo_name_from_https_remote(self, mock_run: MagicMock) -> None:
        """Test getting repo name from HTTPS remote URL."""
        mock_run.return_value = MagicMock(
            stdout="https://github.com/user/my-repo.git\n", returncode=0
        )
        parser = GitLogParser()
        assert parser._get_repo_name(Path("/fake/repo")) == "user/my-repo"

    @patch("subprocess.run")
    def test_get_repo_name_fallback_to_dirname(self, mock_run: MagicMock) -> None:
        """Test falling back to directory name when remote fails."""
        mock_run.side_effect = subprocess.SubprocessError()
        parser = GitLogParser()
        assert parser._get_repo_name(Path("/path/to/my-local-repo")) == "my-local-repo"

    @patch.object(GitLogParser, "_is_git_repo")
    def test_parse_repo_raises_on_non_git(self, mock_is_git: MagicMock) -> None:
        """Test parse_repo raises ValueError for non-git directory."""
        mock_is_git.return_value = False
        parser = GitLogParser()
        with pytest.raises(ValueError, match="Not a git repository"):
            parser.parse_repo(Path("/fake/not-repo"))

    @patch("subprocess.run")
    @patch.object(GitLogParser, "_is_git_repo", return_value=True)
    @patch.object(GitLogParser, "_get_repo_name", return_value="test/repo")
    def test_parse_repo_returns_commits(
        self,
        mock_name: MagicMock,
        mock_is_git: MagicMock,
        mock_run: MagicMock,
    ) -> None:
        """Test parse_repo returns parsed commits."""
        mock_run.return_value = MagicMock(
            stdout=(
                "abc123|John|john@test.com|2024-01-15T10:30:00+00:00|"
                "feat: test|HEAD -> main\n\nBody\n---COMMIT_END---\n"
            ),
            returncode=0,
        )
        parser = GitLogParser()
        commits = parser.parse_repo(Path("/fake/repo"))
        assert len(commits) == 1
        assert commits[0].sha == "abc123"

    @patch.object(GitLogParser, "parse_repo")
    def test_parse_multiple_repos_combines_results(self, mock_parse: MagicMock) -> None:
        """Test parse_multiple_repos combines commits from all repos."""
        now = datetime.now(tz=UTC)
        mock_parse.side_effect = [
            [
                GitHubCommit(
                    sha="abc123",
                    repo="repo1",
                    branch="main",
                    message="First",
                    author_name="A",
                    author_email="a@test.com",
                    vendor_id=None,
                    committed_at=now - timedelta(hours=1),
                )
            ],
            [
                GitHubCommit(
                    sha="def456",
                    repo="repo2",
                    branch="main",
                    message="Second",
                    author_name="B",
                    author_email="b@test.com",
                    vendor_id="claude",
                    committed_at=now,
                )
            ],
        ]
        parser = GitLogParser()
        commits = parser.parse_multiple_repos([Path("/repo1"), Path("/repo2")])
        assert len(commits) == 2
        # Should be sorted by date, newest first
        assert commits[0].sha == "def456"
        assert commits[1].sha == "abc123"

    @patch.object(GitLogParser, "parse_repo")
    def test_parse_multiple_repos_skips_invalid(self, mock_parse: MagicMock) -> None:
        """Test parse_multiple_repos skips invalid repos."""
        mock_parse.side_effect = [
            ValueError("Not a git repo"),
            [
                GitHubCommit(
                    sha="abc123",
                    repo="valid-repo",
                    branch="main",
                    message="Test",
                    author_name="A",
                    author_email="a@test.com",
                    vendor_id=None,
                    committed_at=datetime.now(tz=UTC),
                )
            ],
        ]
        parser = GitLogParser()
        commits = parser.parse_multiple_repos([Path("/invalid"), Path("/valid")])
        assert len(commits) == 1


class TestParseGitLog:
    """Tests for parse_git_log convenience function."""

    @patch.object(GitLogParser, "parse_repo")
    def test_parse_git_log_calls_parser(self, mock_parse: MagicMock) -> None:
        """Test parse_git_log creates parser and calls parse_repo."""
        mock_parse.return_value = []
        result = parse_git_log(Path("/fake/repo"))
        assert result == []
        mock_parse.assert_called_once()


class TestFindGitRepos:
    """Tests for find_git_repos function."""

    def test_find_git_repos_finds_repos(self) -> None:
        """Test finding git repos in directory structure."""
        with tempfile.TemporaryDirectory() as temp_dir:
            base = Path(temp_dir)

            # Create fake git repos
            (base / "repo1" / ".git").mkdir(parents=True)
            (base / "repo2" / ".git").mkdir(parents=True)
            (base / "not-a-repo").mkdir()

            repos = find_git_repos(base)
            repo_names = [r.name for r in repos]
            assert "repo1" in repo_names
            assert "repo2" in repo_names
            assert "not-a-repo" not in repo_names

    def test_find_git_repos_respects_depth(self) -> None:
        """Test find_git_repos respects max_depth parameter."""
        with tempfile.TemporaryDirectory() as temp_dir:
            base = Path(temp_dir)

            # Create shallow repo (depth 1)
            (base / "shallow" / ".git").mkdir(parents=True)

            # Create deep repo (depth 4)
            (base / "a" / "b" / "c" / "deep" / ".git").mkdir(parents=True)

            # With default depth 3, should only find shallow
            repos = find_git_repos(base, max_depth=2)
            repo_names = [r.name for r in repos]
            assert "shallow" in repo_names
            assert "deep" not in repo_names

            # With higher depth, should find both
            repos = find_git_repos(base, max_depth=5)
            repo_names = [r.name for r in repos]
            assert "shallow" in repo_names
            assert "deep" in repo_names

    def test_find_git_repos_skips_hidden_dirs(self) -> None:
        """Test find_git_repos skips hidden directories."""
        with tempfile.TemporaryDirectory() as temp_dir:
            base = Path(temp_dir)

            # Create visible repo
            (base / "visible" / ".git").mkdir(parents=True)

            # Create hidden directory with repo
            (base / ".hidden" / "secret" / ".git").mkdir(parents=True)

            repos = find_git_repos(base)
            repo_names = [r.name for r in repos]
            assert "visible" in repo_names
            assert "secret" not in repo_names

    def test_find_git_repos_doesnt_recurse_into_repos(self) -> None:
        """Test find_git_repos doesn't recurse into git repos."""
        with tempfile.TemporaryDirectory() as temp_dir:
            base = Path(temp_dir)

            # Create parent repo
            (base / "parent" / ".git").mkdir(parents=True)
            # Create nested repo (should not be found)
            (base / "parent" / "nested" / ".git").mkdir(parents=True)

            repos = find_git_repos(base)
            repo_names = [r.name for r in repos]
            assert "parent" in repo_names
            assert "nested" not in repo_names

    def test_find_git_repos_handles_permission_errors(self) -> None:
        """Test find_git_repos handles permission errors gracefully."""
        with tempfile.TemporaryDirectory() as temp_dir:
            base = Path(temp_dir)

            # Create an accessible repo
            (base / "accessible" / ".git").mkdir(parents=True)

            # Create a directory that will raise PermissionError when iterdir() is called
            restricted = base / "restricted"
            restricted.mkdir()

            # Mock iterdir to raise PermissionError for the restricted directory
            original_iterdir = Path.iterdir

            def mock_iterdir(self: Path) -> object:
                if self == restricted:
                    raise PermissionError("Permission denied")
                return original_iterdir(self)

            with patch.object(Path, "iterdir", mock_iterdir):
                repos = find_git_repos(base)
                repo_names = [r.name for r in repos]
                # Should still find the accessible repo
                assert "accessible" in repo_names
                # Should not crash on permission error
                assert len(repos) >= 1


class TestGitLogParserIntegration:
    """Integration tests using actual git commands (if available)."""

    @pytest.fixture
    def temp_git_repo(self) -> Path:
        """Create a temporary git repository for testing."""
        with tempfile.TemporaryDirectory() as temp_dir:
            repo_path = Path(temp_dir)

            # Initialize git repo
            try:
                subprocess.run(
                    ["git", "init"],
                    cwd=repo_path,
                    capture_output=True,
                    check=True,
                    timeout=10,
                )
                subprocess.run(
                    ["git", "config", "user.email", "test@example.com"],
                    cwd=repo_path,
                    capture_output=True,
                    check=True,
                    timeout=10,
                )
                subprocess.run(
                    ["git", "config", "user.name", "Test User"],
                    cwd=repo_path,
                    capture_output=True,
                    check=True,
                    timeout=10,
                )

                # Create initial commit
                (repo_path / "README.md").write_text("# Test Repo")
                subprocess.run(
                    ["git", "add", "."],
                    cwd=repo_path,
                    capture_output=True,
                    check=True,
                    timeout=10,
                )
                subprocess.run(
                    ["git", "commit", "-m", "Initial commit"],
                    cwd=repo_path,
                    capture_output=True,
                    check=True,
                    timeout=10,
                )

                yield repo_path
            except (subprocess.SubprocessError, FileNotFoundError):
                pytest.skip("Git not available or failed to initialize repo")

    def test_parse_real_repo(self, temp_git_repo: Path) -> None:
        """Test parsing a real git repository."""
        parser = GitLogParser()
        commits = parser.parse_repo(temp_git_repo)

        assert len(commits) >= 1
        assert commits[0].message == "Initial commit"
        assert commits[0].author_name == "Test User"
        assert commits[0].author_email == "test@example.com"

    def test_parse_repo_with_ai_commit(self, temp_git_repo: Path) -> None:
        """Test parsing repo with AI-attributed commit."""
        # Add a file and commit with Claude signature
        (temp_git_repo / "feature.py").write_text("# Feature")
        subprocess.run(
            ["git", "add", "."],
            cwd=temp_git_repo,
            capture_output=True,
            check=True,
            timeout=10,
        )
        subprocess.run(
            [
                "git",
                "commit",
                "-m",
                "feat: add feature\n\nGenerated with [Claude Code]",
            ],
            cwd=temp_git_repo,
            capture_output=True,
            check=True,
            timeout=10,
        )

        parser = GitLogParser()
        commits = parser.parse_repo(temp_git_repo)

        # Most recent commit should be AI-attributed
        assert commits[0].vendor_id == "claude"
        assert commits[0].is_ai_attributed is True


class TestDetectVendorAttributionDetailed:
    """Tests for detect_vendor_attribution_detailed function."""

    def test_claude_signature_returns_high_confidence(self) -> None:
        """Test Claude signature detection returns confidence 1.0."""
        vendor, confidence, method = detect_vendor_attribution_detailed(
            "Generated with [Claude Code]"
        )
        assert vendor == "claude"
        assert confidence == 1.0
        assert method == "signature"

    def test_gemini_signature_detection(self) -> None:
        """Test Gemini signature detection."""
        vendor, confidence, method = detect_vendor_attribution_detailed("Generated by Gemini")
        assert vendor == "gemini"
        assert confidence == 1.0
        assert method == "signature"

    def test_openai_signature_detection(self) -> None:
        """Test OpenAI signature detection."""
        vendor, confidence, method = detect_vendor_attribution_detailed("Generated by OpenAI")
        assert vendor == "openai"
        assert confidence == 1.0
        assert method == "signature"

    def test_chatgpt_detection(self) -> None:
        """Test ChatGPT pattern detection."""
        vendor, confidence, method = detect_vendor_attribution_detailed("Created with ChatGPT")
        assert vendor == "openai"
        assert confidence == 1.0
        assert method == "signature"

    def test_email_domain_anthropic(self) -> None:
        """Test Anthropic email domain detection."""
        vendor, confidence, method = detect_vendor_attribution_detailed(
            "Some commit message",
            author_email="user@anthropic.com",
        )
        assert vendor == "claude"
        assert confidence == 0.8
        assert method == "email_domain"

    def test_email_domain_google(self) -> None:
        """Test Google email domain detection for Gemini."""
        vendor, confidence, method = detect_vendor_attribution_detailed(
            "Some commit message",
            author_email="user@google.com",
        )
        assert vendor == "gemini"
        assert confidence == 0.8
        assert method == "email_domain"

    def test_email_domain_openai(self) -> None:
        """Test OpenAI email domain detection."""
        vendor, confidence, method = detect_vendor_attribution_detailed(
            "Some commit message",
            author_email="user@openai.com",
        )
        assert vendor == "openai"
        assert confidence == 0.8
        assert method == "email_domain"

    def test_no_attribution_returns_none(self) -> None:
        """Test no attribution returns None with 0.0 confidence."""
        vendor, confidence, method = detect_vendor_attribution_detailed("Regular commit message")
        assert vendor is None
        assert confidence == 0.0
        assert method == "none"

    def test_signature_takes_priority_over_email(self) -> None:
        """Test signature detection takes priority over email domain."""
        vendor, confidence, method = detect_vendor_attribution_detailed(
            "Generated with [Claude Code]",
            author_email="user@openai.com",
        )
        assert vendor == "claude"
        assert confidence == 1.0
        assert method == "signature"


class TestAttribution:
    """Tests for Attribution dataclass."""

    def test_attribution_creation(self) -> None:
        """Test creating Attribution object."""
        attr = Attribution(
            resource_type="commit",
            resource_id="abc1234",
            repo="test/repo",
            vendor_id="claude",
            confidence=1.0,
            detection_method="signature",
            detected_at=datetime.now(UTC),
        )
        assert attr.resource_type == "commit"
        assert attr.resource_id == "abc1234"
        assert attr.vendor_id == "claude"
        assert attr.confidence == 1.0

    def test_attribution_with_none_vendor(self) -> None:
        """Test Attribution with no vendor detected."""
        attr = Attribution(
            resource_type="issue",
            resource_id="42",
            repo="test/repo",
            vendor_id=None,
            confidence=0.0,
            detection_method="none",
            detected_at=datetime.now(UTC),
        )
        assert attr.vendor_id is None
        assert attr.confidence == 0.0


class TestCreateAttribution:
    """Tests for create_attribution function."""

    def test_create_attribution_from_claude_content(self) -> None:
        """Test creating attribution from Claude signature."""
        attr = create_attribution(
            resource_type="commit",
            resource_id="abc1234",
            repo="test/repo",
            content="Generated with [Claude Code]",
        )
        assert attr.vendor_id == "claude"
        assert attr.confidence == 1.0
        assert attr.detection_method == "signature"

    def test_create_attribution_from_email(self) -> None:
        """Test creating attribution from email domain."""
        attr = create_attribution(
            resource_type="pr",
            resource_id="123",
            repo="test/repo",
            content="Regular PR description",
            author_email="user@anthropic.com",
        )
        assert attr.vendor_id == "claude"
        assert attr.confidence == 0.8
        assert attr.detection_method == "email_domain"

    def test_create_attribution_no_match(self) -> None:
        """Test creating attribution when no match found."""
        attr = create_attribution(
            resource_type="issue",
            resource_id="42",
            repo="test/repo",
            content="Regular issue description",
        )
        assert attr.vendor_id is None
        assert attr.confidence == 0.0


class TestDetectPRAttribution:
    """Tests for detect_pr_attribution function."""

    def test_pr_body_attribution(self) -> None:
        """Test PR attribution from body content."""
        vendor, confidence, method = detect_pr_attribution(
            title="Add new feature",
            body="Generated with [Claude Code]",
        )
        assert vendor == "claude"
        assert confidence == 1.0
        assert method == "signature"

    def test_pr_title_attribution(self) -> None:
        """Test PR attribution from title when body has none."""
        vendor, confidence, method = detect_pr_attribution(
            title="Generated by Gemini: Add feature",
            body="Regular description",
        )
        assert vendor == "gemini"
        assert confidence == 1.0
        assert method == "signature"

    def test_pr_commit_attribution(self) -> None:
        """Test PR attribution from commits when title/body have none."""
        vendor, confidence, method = detect_pr_attribution(
            title="Add feature",
            body="Regular description",
            commits=["feat: add feature\n\nGenerated with [Claude Code]"],
        )
        assert vendor == "claude"
        # Confidence is lowered slightly for commit-based detection
        assert confidence == 0.9
        assert method == "commit_signature"

    def test_pr_no_attribution(self) -> None:
        """Test PR with no attribution found."""
        vendor, confidence, method = detect_pr_attribution(
            title="Add feature",
            body="Regular description",
            commits=["Regular commit message"],
        )
        assert vendor is None
        assert confidence == 0.0
        assert method == "none"

    def test_pr_body_takes_priority_over_commits(self) -> None:
        """Test PR body attribution takes priority over commits."""
        vendor, confidence, method = detect_pr_attribution(
            title="Add feature",
            body="Generated by OpenAI",
            commits=["Generated with [Claude Code]"],
        )
        assert vendor == "openai"
        assert confidence == 1.0
        assert method == "signature"

    def test_pr_empty_commits_list(self) -> None:
        """Test PR attribution with empty commits list."""
        vendor, confidence, method = detect_pr_attribution(
            title="Add feature",
            body="Regular description",
            commits=[],
        )
        assert vendor is None
        assert confidence == 0.0

    def test_pr_none_commits(self) -> None:
        """Test PR attribution with None commits."""
        vendor, confidence, method = detect_pr_attribution(
            title="Add feature",
            body="Regular description",
            commits=None,
        )
        assert vendor is None
        assert confidence == 0.0


class TestVendorEmailDomains:
    """Tests for VENDOR_EMAIL_DOMAINS constant."""

    def test_claude_domains_exist(self) -> None:
        """Test Claude email domains are defined."""
        assert "claude" in VENDOR_EMAIL_DOMAINS
        assert "anthropic.com" in VENDOR_EMAIL_DOMAINS["claude"]

    def test_gemini_domains_exist(self) -> None:
        """Test Gemini email domains are defined."""
        assert "gemini" in VENDOR_EMAIL_DOMAINS
        assert "google.com" in VENDOR_EMAIL_DOMAINS["gemini"]

    def test_openai_domains_exist(self) -> None:
        """Test OpenAI email domains are defined."""
        assert "openai" in VENDOR_EMAIL_DOMAINS
        assert "openai.com" in VENDOR_EMAIL_DOMAINS["openai"]
